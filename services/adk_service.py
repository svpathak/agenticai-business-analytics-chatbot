from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.genai import types
import streamlit as st
import streamlit_echarts
import uuid
import asyncio
from master_agent import root_agent
from config.settings import APP_NAME_FOR_ADK, USER_ID, INITIAL_STATE, ADK_SESSION_KEY

async def create_adk_session(session_service: InMemorySessionService, session_id: str):
    await session_service.create_session(
        app_name=APP_NAME_FOR_ADK,
        user_id=USER_ID,
        session_id=session_id,
        state=INITIAL_STATE
    )

@st.cache_resource
def initialize_adk():
    """
    Initializes the Google ADK Runner and manages the ADK session.
    Uses Streamlit's cache_resource decorator to ensure this runs only once per app load.
    """
    session_service = InMemorySessionService()
    runner = Runner(
        app_name=APP_NAME_FOR_ADK,
        agent=root_agent,
        session_service=session_service
    )

    # Check if an ADK session ID already exists in Streamlit's session state.
    if ADK_SESSION_KEY not in st.session_state:
        # If not, create a new unique session ID and store it.
        session_id = f"streamlit_adk_session_{uuid.uuid4()}"
        st.session_state[ADK_SESSION_KEY] = session_id
        # Create a new session in ADK's session service.
        asyncio.run(create_adk_session(session_service=session_service, session_id=session_id))
    else:
        # If an ADK session ID already exists (e.g., on a Streamlit rerun), retrieve it.
        session_id = st.session_state[ADK_SESSION_KEY]
        # Verify if the session still exists in the ADK session service.
        # This handles cases where the service might reset (less common with cache_resource, but good practice).
        if not session_service.get_session(app_name=APP_NAME_FOR_ADK, user_id=USER_ID, session_id=session_id):
            # If the session was lost (e.g., full app restart without clearing cache), recreate it.
            asyncio.run(create_adk_session(session_service=session_service, session_id=session_id))

    print(f"session_id returned from initialize_adk(): {session_id}")
    return runner, session_id

async def run_adk_async(runner: Runner, session_id: str, user_message_text: str):
    """
    Asynchronously runs a single turn of the ADK agent conversation.
    """
    session = await runner.session_service.get_session(app_name=APP_NAME_FOR_ADK,user_id=USER_ID,session_id=session_id)
    if not session:
        return "Error: ADK session not found."
    # Prepare the user's message in the format expected by ADK/Gemini.
    content = types.Content(role='user', parts=[types.Part(text=user_message_text)])
    final_response_text = "[Agent encountered an issue]" # Default error message
    chart_objects = None
    
    # Iterate through the asynchronous events generated by the ADK runner.
    # ADK can yield multiple events (e.g., tool calls, interim responses) before the final response.
    async for event in runner.run_async(
        user_id=USER_ID,
        session_id=session_id,
        new_message=content
        ):
        
        if hasattr(event,"author") and event.author == "data_chart_agent":
            if event.is_final_response():
                if event.content and event.content.parts and hasattr(event.content.parts[0], 'text'):
                    chart_objects = event.content.parts[0].text
                    if chart_objects == "```json {}```":
                        chart_objects = None

        if hasattr(event,"author") and event.author == "query_response_agent":
            if event.is_final_response(): # Check for the final response from the agent.
                if event.content and event.content.parts and hasattr(event.content.parts[0], 'text'):
                    final_response_text = event.content.parts[0].text
                print(f"capturing final response from {event.author}")
                break # Exit the loop once the final response is received.
    return final_response_text, chart_objects

def run_adk_sync(runner: Runner, session_id: str, user_message_text: str) -> str:
    """
    Synchronous wrapper for running ADK, as Streamlit does not directly support async calls in the main thread.
    """
    # Runs the asynchronous function in a new event loop.
    return asyncio.run(run_adk_async(runner, session_id, user_message_text))    